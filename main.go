package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
)

type ElasticInfos struct {
	alias string
	index string
}

func deleteEmpty(s []string) []string {
	var r []string
	for _, str := range s {
		if str != "" {
			r = append(r, str)
		}
	}
	return r
}

func bodyToString(reader io.ReadCloser) string {
	body, err := ioutil.ReadAll(reader)
	if err != nil {
		panic(err)
	}
	return string(body)
}

func deleteRequest(url string) (string, error) {
	println("Delete request :", url)
	req, err := http.NewRequest("DELETE", url, nil)
	if err != nil {
		return "", (err)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", (err)
	}
	defer resp.Body.Close()
	return bodyToString(resp.Body), nil
}

func main() {

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	resp, err := http.Get("http://localhost:9200/_cat/aliases")
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	sbody := bodyToString(resp.Body)
	println(sbody)

	lines := strings.Split(sbody, "\n")
	lines = deleteEmpty(lines)
	linesLen := len(lines)
	println(linesLen, "aliases found.")

	var infos []ElasticInfos
	for _, line := range lines {
		elasticLine := strings.Fields(line)

		tmp := ElasticInfos{elasticLine[0], elasticLine[1]}

		infos = append(infos, tmp)
	}

	// fmt.Printf("%+v\n", infos)

	for _, info := range infos {
		fmt.Println(info)

		aliasURL := fmt.Sprintf("http://localhost:9200/%s/_alias/%s", info.index, info.alias)
		indiceURL := fmt.Sprintf("http://localhost:9200/%s", info.index)

		aliasResp, err := deleteRequest(aliasURL)
		if err != nil {
			panic(err)
		}
		indiceResp, err := deleteRequest(indiceURL)
		if err != nil {
			panic(err)
		}
		println(aliasURL)
		println(aliasResp)
		println(indiceResp)

	}

}
